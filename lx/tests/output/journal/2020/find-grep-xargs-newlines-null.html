<html>
                            <head>
                                <link rel="stylesheet" href="/light.css" media="(prefers-color-scheme: light)" />
                                <link rel="stylesheet" href="/dark.css" media="(prefers-color-scheme: dark)" />
                            </head>
                            <body>
                                <p>See <a href="/journal/follow-up-on-command-line-finding-and-filtering/">the follow-up</a> post, in which I show an easier and faster way of doing this… as long as you have the GNU versions of the utilities, or alternatives like <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>.</p>
<p><b>Summary:</b> If you want to find files, filter them on file name, and pipe the result into some other Unix command (e.g. <code>wc</code> to count words), use <code>tr</code> to substitute the null character for newlines:</p>
<pre><code class='Bourne Again Shell (bash)'><span class="source shell bash"><span class="meta function-call shell"><span class="variable function shell">$</span></span><span class="meta function-call arguments shell"> find notes<span class="variable parameter option shell"><span class="punctuation definition parameter shell"> -</span>name</span> <span class="string quoted double shell"><span class="punctuation definition string begin shell">&quot;</span>.md<span class="punctuation definition string end shell">&quot;</span></span></span> <span class="keyword operator logical pipe shell">|</span><span class="punctuation separator continuation line shell">\
</span>  grep &quot;notes/2020&quot; |\
  tr &#39;\n&#39; &#39;\0&#39; |\
  xargs -0 wc -w
</span></code></pre>
<hr />
<p>I sometimes want to use find subset of files matching a pattern, further filter it with grep, and then do something with the results using <code>xargs</code>—most often, something like counting the words in the subset I found. The basic flow I want is:</p>
<pre><code class='Bourne Again Shell (bash)'><span class="source shell bash"><span class="meta function-call shell"><span class="variable function shell">$</span></span><span class="meta function-call arguments shell"> <span class="keyword operator assignment redirection shell">&lt;</span>find files<span class="keyword operator assignment redirection shell">&gt;</span> </span><span class="keyword operator logical pipe shell">|</span> <span class="meta function-call shell"></span><span class="meta function-call arguments shell"><span class="keyword operator assignment redirection shell">&lt;</span>filter files<span class="keyword operator assignment redirection shell">&gt;</span> </span><span class="keyword operator logical pipe shell">|</span> <span class="meta function-call shell"></span><span class="meta function-call arguments shell"><span class="keyword operator assignment redirection shell">&lt;</span>count the words in each<span class="keyword operator assignment redirection shell">&gt;</span>
</span></span></code></pre>
<p>My first instinct (and possibly yours if you’re reading this via a web search!) is to use <code>find</code><sup class="footnote-reference"><a href="#fd">1</a></sup> to get the first set of files, do the further filtering with <code>grep</code>,<sup class="footnote-reference"><a href="#rg">2</a></sup> and finally use <code>xargs</code> to pipe the results into <code>wc -w</code>.<sup class="footnote-reference"><a href="#cw">3</a></sup></p>
<p>The first problem is that <code>wc</code>, like most Unix commands, assumes that its arguments are space-delimited. If you hand any standard Unix utility a bunch of files where any of them have spaces in their names, you’ll see reports that various files don’t exist—where the “file” named is just one part of an actual file name.</p>
<p>Normally, I solve this kind of thing using <code>xargs -0</code>, which uses the null <code>\0</code> character as the separator for arguments to the function you invoke. If I were <em>just</em> using <code>find</code>, I would use its <code>-print0</code> flag. If I were <em>just</em> using <code>grep</code>, I would use its <code>--null</code> flag.<sup class="footnote-reference"><a href="#rg-1">4</a></sup> Unfortunately, here I’m combining them. Since I’m not working with the output from <code>find</code> directly, its <code>-print0</code> expression isn’t useful: those results will be piped into <code>grep</code>, which prints each result on a line. Meanwhile, <code>grep --null</code> separates <em>file results</em> with <code>\0</code>, but does not separate results from within a stream of text—which is what <code>grep</code> sees when we pipe the results of <code>find</code> into it. No matter what I did, I kept seeing the error:</p>
<blockquote>
<p>open: File name too long</p>
</blockquote>
<p>The problem was that there were no <code>\0</code> characters in the stream going into <code>wc</code>, but I was invoking it as <code>xargs -0 wc -c</code>, so it was trying to treat the list of <em>all</em> the matching files as a <em>single argument</em>… which, at over 12,000 characters long, far exceeded the operating system’s limits for file paths (on <em>any</em> file system in common use today).</p>
<p>After thinking about this for a few, I realized I needed to treat <code>grep</code> output as a plain text stream, rather than a list of files. Then the question was how to substitute the null character <code>\0</code> for each of the newlines <code>\n</code> in that stream. My first thought was to use <code>sed</code>, but <code>sed</code> works on <em>lines</em>, using <code>\n</code> as its separator, so you have to do shenanigans to get it to work. Much easier is to use <code>tr</code>, a utility I had never heard of before today, which is used to <i>translate characters</i>. (Credit to <a href="https://stackoverflow.com/questions/1251999/how-can-i-replace-a-newline-n-using-sed">this Stack Overflow question</a> for teaching me <em>both</em> of these things!) The <code>tr</code> man page’s description:</p>
<blockquote>
<p>The <b>tr</b> utility copies the standard input to the standard output with substitution or deletion of selected characters.</p>
</blockquote>
<p>While it can do substantially more sophisticated transformations than this, too, it’s perfect for this simple text replacement: <code>tr '\n' '\0'</code> substitutes the null character <code>\0</code> for every newline in the input stream—and <em>then</em> <code>xargs -0</code> will do what we need. The final workflow looks like this (separated onto multiple lines so it’s easier to follow):<sup class="footnote-reference"><a href="#my-way">5</a></sup></p>
<pre><code class='Bourne Again Shell (bash)'><span class="source shell bash"><span class="meta function-call shell"><span class="variable function shell">$</span></span><span class="meta function-call arguments shell"> find<span class="variable parameter option shell"><span class="punctuation definition parameter shell"> -</span>name</span> <span class="string quoted double shell"><span class="punctuation definition string begin shell">&quot;</span>.md<span class="punctuation definition string end shell">&quot;</span></span> notes</span> <span class="keyword operator logical pipe shell">|</span><span class="constant character escape shell">\ </span> <span class="comment line number-sign shell"><span class="punctuation definition comment begin shell">#</span></span><span class="comment line number-sign shell"> find the files</span><span class="comment line number-sign shell">
</span>  <span class="meta function-call shell"><span class="variable function shell">grep</span></span><span class="meta function-call arguments shell"> <span class="string quoted double shell"><span class="punctuation definition string begin shell">&quot;</span>notes/2020<span class="punctuation definition string end shell">&quot;</span></span></span> <span class="keyword operator logical pipe shell">|</span><span class="constant character escape shell">\ </span>      <span class="comment line number-sign shell"><span class="punctuation definition comment begin shell">#</span></span><span class="comment line number-sign shell"> filter them</span><span class="comment line number-sign shell">
</span>  <span class="meta function-call shell"><span class="variable function shell">tr</span></span><span class="meta function-call arguments shell"> <span class="string quoted single shell"><span class="punctuation definition string begin shell">&#39;</span>\n<span class="punctuation definition string end shell">&#39;</span></span> <span class="string quoted single shell"><span class="punctuation definition string begin shell">&#39;</span>\0<span class="punctuation definition string end shell">&#39;</span></span></span> <span class="keyword operator logical pipe shell">|</span><span class="constant character escape shell">\ </span>           <span class="comment line number-sign shell"><span class="punctuation definition comment begin shell">#</span></span><span class="comment line number-sign shell"> replace newline with null</span><span class="comment line number-sign shell">
</span>  <span class="meta function-call shell"><span class="variable function shell">xargs</span></span><span class="meta function-call arguments shell"><span class="variable parameter option shell"><span class="punctuation definition parameter shell"> -</span>0</span> wc<span class="variable parameter option shell"><span class="punctuation definition parameter shell"> -</span>w             <span class="comment line number-sign shell"><span class="punctuation definition comment begin shell">#</span></span><span class="comment line number-sign shell"> word count each file!</span><span class="comment line number-sign shell">
</span></span></span></span></code></pre>
<p>In sum: today I learned that—</p>
<ul>
<li><code>grep</code> treats <em>streams</em> differently than <em>files</em></li>
<li><code>sed</code> doesn’t (easily) work with newlines <code>\n</code></li>
<li><code>tr</code> <em>exists</em> and is great for simple character substitution throughout a stream of text</li>
</ul>
<div class="footnote-definition" id="fd"><sup class="footnote-definition-label">1</sup>
<p>Or the lovely and very fast <a href="https://github.com/sharkdp/fd">Rust-powered alternative, <code>fd</code></a>—but the exact same set of challenges in the rest of this post apply whichever you’re using.</p>
</div>
<div class="footnote-definition" id="rg"><sup class="footnote-definition-label">2</sup>
<p>Here I’m usually using <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>, which is <em>also</em> powered by Rust and is <em>ridiculous</em> fast, but again: the same constraints apply.</p>
</div>
<div class="footnote-definition" id="cw"><sup class="footnote-definition-label">3</sup>
<p>And here I’m usually using <a href="https://github.com/Freaky/cw">cw</a>, yet another very fast Rust implementation of a utility.</p>
</div>
<div class="footnote-definition" id="rg-1"><sup class="footnote-definition-label">4</sup>
<p>The same goes for <code>rg --null</code> and its <code>rg -0</code> shorthand.</p>
</div>
<div class="footnote-definition" id="my-way"><sup class="footnote-definition-label">5</sup>
<p>In fact, this looked a <em>little</em> different, because I was using all the Rust-powered substitutes:</p>
<pre><code class='Bourne Again Shell (bash)'><span class="source shell bash"><span class="meta function-call shell"><span class="variable function shell">$</span></span><span class="meta function-call arguments shell"> fd <span class="string quoted double shell"><span class="punctuation definition string begin shell">&quot;</span>.md<span class="punctuation definition string end shell">&quot;</span></span> notes</span> <span class="keyword operator logical pipe shell">|</span><span class="constant character escape shell">\ </span>  <span class="comment line number-sign shell"><span class="punctuation definition comment begin shell">#</span></span><span class="comment line number-sign shell"> find the files</span><span class="comment line number-sign shell">
</span>  <span class="meta function-call shell"><span class="variable function shell">rg</span></span><span class="meta function-call arguments shell"> <span class="string quoted double shell"><span class="punctuation definition string begin shell">&quot;</span>notes/2020<span class="punctuation definition string end shell">&quot;</span></span></span> <span class="keyword operator logical pipe shell">|</span><span class="constant character escape shell">\ </span> <span class="comment line number-sign shell"><span class="punctuation definition comment begin shell">#</span></span><span class="comment line number-sign shell"> filter them</span><span class="comment line number-sign shell">
</span>  <span class="meta function-call shell"><span class="variable function shell">tr</span></span><span class="meta function-call arguments shell"> <span class="string quoted single shell"><span class="punctuation definition string begin shell">&#39;</span>\n<span class="punctuation definition string end shell">&#39;</span></span> <span class="string quoted single shell"><span class="punctuation definition string begin shell">&#39;</span>\0<span class="punctuation definition string end shell">&#39;</span></span></span> <span class="keyword operator logical pipe shell">|</span><span class="constant character escape shell">\ </span>    <span class="comment line number-sign shell"><span class="punctuation definition comment begin shell">#</span></span><span class="comment line number-sign shell"> replace newline with null</span><span class="comment line number-sign shell">
</span>  <span class="meta function-call shell"><span class="variable function shell">xargs</span></span><span class="meta function-call arguments shell"><span class="variable parameter option shell"><span class="punctuation definition parameter shell"> -</span>0</span> cw<span class="variable parameter option shell"><span class="punctuation definition parameter shell"> -</span>w      <span class="comment line number-sign shell"><span class="punctuation definition comment begin shell">#</span></span><span class="comment line number-sign shell"> word count each file!</span><span class="comment line number-sign shell">
</span></span></span></span></code></pre></div>

                            </body>
                        </html>